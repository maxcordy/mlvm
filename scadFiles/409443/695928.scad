/*
date:		 2014 
author:	 Lukas SÃ¼ss aka mechadense
title:	 customizable space filling Wiegner Seiz Cell building blocks
license:	 CC-BY-SA


## Description:

This is a structural construction kit.
It uses a natural set of construction blocks which can fill/divide space.
These blocks are based on natural basic crystal structures with high symmetries.
This makes the construction kit more direction independent then conventional ones.


### user defined blocks:

Generate more building blocks (& couplers bricks) by entering the
coordinates of the local nearest neighbours. (Only if the entered nearest neighbours are correctly taken from a proper crystal structure the resulting body will form a solitary space filler.)


### Science:

The basic blocks are the Wiegner-Seitz cells of the following crystal lattices 
bcc - body centered cubic
fcc or ccp - face centered cubic or cubic closed packed
hcp - hexagonal close packed
some other voroni cells (e.g. one of a diamond atom) are also included


### Future application:

In atomically precise products such blocks can incorporate diverse basic functions and be used as recomposable microcomponents that can form diverse metamaterials.
Choosing these shapes might be desirable because of the ease to reason about them and their good physical properties.
E.g. in bcc cells:
  Easy reasoning: 
    cube faces - kartesian
    octahedral faces - normal to diamond bonds
    (choosing a main crystal orientation for the housing structure might be sensible) 
  Good properties:
    not too anisotropic
    edges have no sharp only oblate angles 
    surfaces of aggregates form pockets so Van-der-Waals assembly can easily be used
    (Van-der-Waals forces can be pretty strong)


investigations revealed this strongly related kit:
http://www.georgehart.com/rp/FCC.html




-------------
-------------

### Some further notes:

unless otherwise noted the [111] direction is always orientated upwards
simple cubic unit cell sidelength is sqrt(3)
this is choosen because it makes the smallest vetors needed length 1

Creating coupling blocks for connection of different highly symmetric basic building blocks can quickly leads to a combinatoric explosion thus smart decisions should be made here.

-----------
bcc [110]  can be directly coupled to fcc [100]
hcp [???0] can be directly coupled to fcc [100]
-----------
bcc shares the the outermost corners with fcc
oriented with [111] facing in z direction 
bcc has 5 xy planes with vertices on it
fcc has 4 xy planes with vertices on it 
all vertices of a double sized (8x volume) bcc cell can be identified with
some of the vertices of an assembly of 8 fcc base-cells
=> 1 to 4 coupling :S
-----------
wanted: couplings between base cells of different type but with same size
-----------
why can fcc diamond be built up from a sparse net of bcc WS cells 
(filling exactly half of space)?!
(is the same possible for the hcp lonsdaleite structure)
-----------
diamond lattice can switch between fcc (diamond) and hcp (lonsdaleite)
a sparse net of bcc Wiegner Seiz cells WSC (truncated octahedrons) can do too


#####################

TODO

# improve nomenclature
# implement basic bcc-fcc couplig(s)
# look into other couplings
* find most natural interfaces between space fillers
* keep orientations seperate
* unify different bcc neighbourpointclouds
* add symmetries for less entry effort? rotsym = 1; // [1,2,3,4,6]
### better cutter-auto-size-choosement
# maybe: add lattice preview with render() --note slow in customizer

*/




//#########################################

// customizer camera orientation
// preview[view:south, tilt:front]

// -----------------------------------------

/* [brick type] */

body = "hcp"; // [hcp:trapezo-rhombic dodecahedron,ccp:rhombic dodecahedron,bcc1:truncated octahedron,bcc2:truncated octahedron (alt),diam:triakis truncated tetrahedron,userdef:user defined]

// part preview (all of them will be generated by customizer)
// part = "all";



/* [User defined] */
ps_userdef = [[+1,0,0],[-1,0,0],[0,+1,0],[0,-1,0],[0,0,+1],[0,0,-1]];



/* [Sizes] */

// scaling factor
// basic overall scale (does not affect connector holes)
1_scale = 9;
s = 1_scale; // 12,14

// cuttercube size - hack because of the lack of infinite objects
// base sites are around 1
// s0 should always be big enough because it gets scaled with s
// keep big enough to supress artifacts
2_cutterhalfspacesize = 3;
s0 = 2_cutterhalfspacesize;

// make the building blocks hollow (no connectors; slower rendering)
hollow = "no";// [yes,no]

// wall thickness (if hollow)
wall_thickness = 1.5;
twall = wall_thickness;  // <<<<<<<<<<<< TODO CHECK FOR CORRECTNESS !!!!

// if hollowed out keep the peghole-walls (slower rendering)
// hangs OpenSCAD :( thus hidden
keepconnectorwalls = "no"*1; //[no,yes]

// show the centers of the neighbouring cells
show_neighbourcenters = "no"; // [no,yes]

// vertex indicator size
svertex = 1; // <<<<<<<<<<<<<<<<< CHECK IF OK

// keep 1 for part compatibility (buggy)
scalz = 1;





/* [Connectors] */

connectors_on = "yes"; // [yes,no]

// diameter - add clearance
dconn = 3.2;

// connector indent depth
depthconn = 4;

// maybe todo -- allow for "Lego Technic" connectors (for high resol. printers) ?






// not shown by customizer - well not completely but why? -> [...]*1 used
/* [Hidden] */


// resolution for peg cuts
$fa = 5;
$fs = 0.2;



// base vectors

// hexagonal base vectors
h1 = [1,0,0]*1; // this makes the base cell sidelength sqrt(3) !! <<<<<<<<<<
h2 = [-1/2, sqrt(3)/2,0]*1;
h3 = [-1/2,-sqrt(3)/2,0]*1;
hz = [0,0,sqrt(2)*scalz]*1;
// linear combinations of those can from face centered vertices
// all points a distance of 1 away


// sp3 hybridisation base vectors
d  = sqrt(2)*1; // 1/sqrt(3)??
d1 = [+d,+d,+d]*1;
d2 = [-d,-d,+d]*1;
d3 = [-d,+d,-d]*1;
d4 = [+d,-d,-d]*1;

sq3 = sqrt(3)*1;

// coordinates from body centered vertex
// [111] facing up for consistency
alpha = 2*asin(sqrt(1/3));
beta  = 2*asin(sqrt(2/3));
gamma = 90-alpha;
// alpha+beta/2 == 90
bcc_l = (sq3/2)*sq3; // sqrt(3) ... basecell sidelength
//bcc_l = (sqrt(6)/2); // sqrt(2) ... basecell sidelength
// why is this soo small ????????? factor 2??
bcc_z = [0,0,bcc_l]*1;
bcc_1 = [bcc_l*cos(gamma),0,bcc_l*sin(gamma)]*1;
bcc_2 = [-bcc_l*cos(gamma)*1/2,+bcc_l*cos(gamma)*sq3/2,bcc_l*sin(gamma)]*1;
bcc_3 = [-bcc_l*cos(gamma)*1/2,-bcc_l*cos(gamma)*sq3/2,bcc_l*sin(gamma)]*1;

// face center coordinate base vectors
f = 0.5*1; // cos(60)
bcc_1fc = [-bcc_l*cos(gamma)*f,0,bcc_l*sin(gamma)]*1;
bcc_2fc = [+bcc_l*cos(gamma)*(1/2)*f,-bcc_l*cos(gamma)*(sq3/2)*f,bcc_l*sin(gamma)]*1;
bcc_3fc = [+bcc_l*cos(gamma)*(1/2)*f,+bcc_l*cos(gamma)*(sq3/2)*f,bcc_l*sin(gamma)]*1;




ps_truncoct = [+bcc_z,-bcc_z,
               +bcc_1,+bcc_2,+bcc_3,
               -bcc_1,-bcc_2,-bcc_3,
               +bcc_z-bcc_1,+bcc_z-bcc_2,+bcc_z-bcc_3,
               -bcc_z+bcc_1,-bcc_z+bcc_2,-bcc_z+bcc_3,
               ]*1;
// near points sqrt(3)/2 = 0.8660 away
// far  points sqrt(2)   = 1.4142 away
ps_cub = [     +bcc_z-bcc_1,+bcc_z-bcc_2,+bcc_z-bcc_3,
               -bcc_z+bcc_1,-bcc_z+bcc_2,-bcc_z+bcc_3,
               ]*1;
ps_oct = [     +bcc_z,-bcc_z,
               +bcc_1,+bcc_2,+bcc_3,
               -bcc_1,-bcc_2,-bcc_3,
               ]*1;




ps_diamond = 
  [
  d1,d2,d3,d4,
        d1-d2,d1-d3,d1-d4,
  d2-d1,      d2-d3,d2-d4,
  d3-d1,d3-d2,      d3-d4,
  d4-d1,d4-d2,d4-d3,
  ]*0.5; //*0.5 hack to keep common s0
ps_diamond_cut = [d1,d2,d3,d4]*0.5;
// does lonsdaleite have a different voroni cell?




// easy switching between spacefills :)
// s=+1 ABABAB hcp stacking (WSC seldom seen in literture)
// s=-1 ABCABC fcc stacking order (WSC = rhombic dodecahedron)
function ps(s) =[
   +h1   -h3,
   +h2-h3,
   -h1+h2   ,
   -h1   +h3,
      -h2+h3,
   +h1-h2   ,
   +h1      +hz,
   +h2      +hz,
   +h3      +hz,
   +h1*s    -hz,
   +h2*s    -hz,
   +h3*s    -hz];

// wanted bcc fcc boundary voroni cell

// bcc to closed packed adapter in 111 direction
// looks nice but seems to create unfillable sharp crevices
// no spacefiller ...
// maybe a rather unnatural coupling
ps_bcc111cp = [
   +h1   -h3,
   +h2-h3,
   -h1+h2   ,
   -h1   +h3,
      -h2+h3,
   +h1-h2   ,
   +h1      +hz,
   +h2      +hz,
   +h3      +hz,
   -bcc_z,
   //+bcc_1,+bcc_2,+bcc_3,
   -bcc_1,-bcc_2,-bcc_3,
   //+bcc_z-bcc_1,+bcc_z-bcc_2,+bcc_z-bcc_3,
   -bcc_z+bcc_1,-bcc_z+bcc_2,-bcc_z+bcc_3,]*1; //?



// coupler between fcc111 and bcc111 of same basecellsize
// asymmetric one (probably very incomplete!!!) 
bcc_coupler1 =[
   +h1   -h3,
   +h2-h3,
   -h1+h2   ,
   -h1   +h3,
      -h2+h3,
   +h1-h2   ,
   +h1      +hz,
   +h2      +hz,
   +h3      +hz,
   //-bcc_z-bcc_1,
   //-bcc_z-bcc_2,
   //-bcc_z-bcc_3, // doubt it !!
   -bcc_z-h1, // ???
   +h1    -hz/*,
   +h2    -hz,
   +h3    -hz*/]*1;

// symmetric one
bcc_coupler2 = [
  +bcc_z, // not necessary -> one less coupler brick :)
  -bcc_z,
  +bcc_1,+bcc_2,+bcc_3,
  -bcc_1,-bcc_2,-bcc_3,
  +bcc_1fc, +bcc_2fc, +bcc_3fc,
  //+bcc_z-bcc_1,+bcc_z-bcc_2,+bcc_z-bcc_3, // not those
  -bcc_z+bcc_1,-bcc_z+bcc_2,-bcc_z+bcc_3,
  ]*1;


ps_hcp = ps(+1);
ps_fcc = ps(-1);


// non sqrt(3) unit cell:

//p1 = [0,0,0];
ps_octahedron = [
      [ 1, 1, 1],
      [ 1, 1,-1],
      [ 1,-1, 1],
      [ 1,-1,-1],
      [-1, 1, 1],
      [-1, 1,-1],
      [-1,-1, 1],
      [-1,-1,-1]]*1;



// ################################################
// #################################################




print_part(); // <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<


module print_part()
{
  if(body=="hcp")
  {
    // Wiegner-Seitz cell of the hcp (hexagonal closed packed) lattice
    body(ps_hcp);
  } 
  else if(body=="ccp")
  {
    // Wiegner-Seitz cell of the
    // fcc==ccp (cubic closed packed == face centered cubic) lattice
    body(ps_fcc);
  }


  else if(body=="bcc1")
  {
    // Wiegner-Seitz cell of the bcc (body centered cubic) lattice
    body(ps_truncoct);
  }
  else if(body=="bcc2")
  {
    // Wiegner-Seitz cell of the bcc (body centered cubic) lattice
    body(ps_truncoct,ps_oct,ps_oct);
  }


  else if(body=="diam")
  {
    //special bodies:
    body(ps_diamond,ps_diamond_cut);
  }
  else if(body=="userdef")
  {
    //userdefined:
    body(ps_userdef);
  } 
  else
  {
    echo("no such object available");
  }
}


//showcenters(ps_fcc,"orange");
//showcenters(ps_hcp,"grey");
//showcenters(ps_truncoct,"pink");
//showcenters(ps_diamond,"blue");


//color("turquoise")
//body(ps_truncoct);


//body(bcc_coupler2); %showcenters(bcc_coupler2);

//basic test
//  body(ps_octahedron);


// somethings wrong with these:
//body(ps_bcc111cp); showcenters(ps_bcc111cp);
//nonstandard orientation:
//  body(ps_truncoct100);
//  showcenters(ps_truncoct100);






// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
module body(ps, pegps=[], hollowps=[])
{

  // if no cutterplanes are specified cut holes in all surfaces
  pegps_ = (pegps == []) ? ps : pegps;  // <<<< trouble bcc vanishes ???

  // same for hollowout
  hollowps_ = (hollowps == []) ? ps : hollowps;

  difference()
  { 
    basebody(ps,0);

    if(connectors_on=="yes") 
    {
      difference()
      {
        connectorcuts(pegps_); // trouble <<<<<<<<<<<<

        if(keepconnectorwalls=="yes")
        {
          // hangs OpenSCAD :(
          connectorcuts(pegps_,twall);
        }
      }
      // difference does not work in swapped order - why?
      if(hollow == "yes") basebody(hollowps_,twall);
    }
  }
  // todo: keep walls for pegs if hollow

  if(show_neighbourcenters=="yes")
  {
    showcenters(ps,"grey");
  }
}



module basebody(ps,shrink=0)
{
    intersection_for(n = [0 : len(ps)-1])
    {
      placecutter(ps[n])
      {
        translate([-s0/2*s-shrink,0,0])
        cube([s0*s,s0*s,s0*s],center=true);
      }
    }
}


module connectorcuts(ps,t=0)
{
    union()
    {
      for(n = [0 : len(ps)-1])
      {
        placecutter(ps[n])
        {
          rotate(90,[0,1,0])
          cylinder(r=dconn/2+t,h=2*depthconn+2*t,center=true);
        }      
      }
    }
}

module placecutter(vec)
{
  x = vec[0]; y = vec[1]; z = vec[2];
  rotate(atan2(y,x),[0,0,1])
    rotate(-atan(z/sqrt(x*x+y*y)),[0,1,0])
      translate([sqrt(x*x+y*y+z*z)/2*s,0,0])
        child();
  echo(vec,sqrt(x*x+y*y+z*z));
}



module showcenters(vecs,color="red") // sow centers of adjacent voroni cells
{
  for(i=[0:len(vecs)-1])
  {
    color(color)
    translate(vecs[i]*s)
      sphere(r=svertex/10*s,$fn=6);
  }
}






// obsolete!!
// [100] faces in z direction - inconsistent with [111] facing in z
/*
dd = d*2; // why not sqrt(2) ??
ps_truncoct100 =
  [
  d1,d2,d3,d4,-d1,-d2,-d3,-d4,
  [+dd,0,0],[-dd,0,0],
  [0,+dd,0],[0,-dd,0],
  [0,0,+dd],[0,0,-dd]
  ];

ps_bcc = [+2*hz,-2*hz,
          +2*h1+hz, +2*h2+hz, +2*h3+hz,
          -2*h1-hz, -2*h2-hz, -2*h3-hz];
*/